"""Module to setup fastapi API to expose API to the outside world."""
import logging
import random
from typing import Any, Dict

from fastapi import FastAPI
import uvicorn

#-----------Additional packages Used-----------------------
import json                                           # To convert a string into dictionary/json type
from starlette.middleware.cors import CORSMiddleware  #To overcome the issue with Access from frontend
#----------------------------------------------------------

ERROR_CODES = [error_code for error_code in range(50)]
LOGGER = logging.getLogger("API")
app = FastAPI()
app.add_middleware(CORSMiddleware, allow_origins=['*'])

#---------Logging into a file-----------------------------
#Used for Validation of logging functionality 
#handler = logging.handlers.RotatingFileHandler(
#              "Log.txt", maxBytes=50000, backupCount=5)
#LOGGER.addHandler(handler)
#LOGGER.setLevel(logging.DEBUG)
#----------------------------------------------------------

#variable to save the number of requests.
REQUESTS = 0


def _generate_lists() -> Dict[str, Any]:
    """Generate resolved, unresolved and backlog lists."""
    return {
        'resolved': [{
            'index': error_idx,
            'code': random.choice(ERROR_CODES),
            'text': 'Error ABC occured, that is `resolved`'
        } for error_idx in range(50)],
        'unresolved': [{
            'index': error_idx,
            'code': random.choice(ERROR_CODES),
            'text': 'Error DEF occured, that is `unresolved`'
        } for error_idx in range(50, 100)],
        'backlog': [{
            'index': error_idx,
            'code': random.choice(ERROR_CODES),
            'text': 'Error XYZ occured, that is in the `backlog`'
        } for error_idx in range(100, 150)]
    }


@app.get("/get_lists")
def get_lists() -> Dict[str, Any]:
    """Return resolved, unresolved and backlog lists."""
    LOGGER.info('Generating resolved, unresolved and backlog lists.')
    global REQUESTS
    REQUESTS = 0
    return _generate_lists()


@app.get("/get_list_intersection_counts")
async def get_list_intersection_counts(err:str):
    """Return the error intersection counts between a set of resolved, unresolved and backlog lists.

    Returns
    -------
    intersection_counts: Dict[str, int]
        The intersection counts between resolved, unresolved and backlog lists, e.g.:
        ```json
        {
            "resolved_unresolved": 12,
            "resolved_backlog": 6,
            "unresolved_backlog": 35
        }
        ```
        `"resolved_unresolved": 12` describes that there are `12` errors with the *same error code*  shared
        between a `resolved` and `unresolved` list, `"resolved_backlog": 6` describes that there are `6`
        errors with the *same error code*  shared between a `resolved` and `backlog` list.

        The three lists required for this calculation are generated by calling `_generate_lists`.

        Code that checks whether errors from the resolved and unresolved list `intersect`, could look like:
        ```python
        error_lists = _generate_lists()
        resolved, unresolved, backlog = error_lists['resolved'], error_lists['unresolved'], error_lists['backlog']

        error_from_resolved = resolved[0]
        error_from_unresolved  = unresolved[0]
        if error_from_resolved.code == error_from_unresolved.code:
            print('Errors intersect')
        else:
            print('Errors do not intersect')
        ```

    """
    LOGGER.info('Generating the intersection counts between a set of resolved, unresolved and backlog lists.')

    #---------------------START OF CODE -----------------------------------------
    
    #error_lists = _generate_lists()
    error_lists = json.loads(str(err))
    resolved, unresolved, backlog = error_lists['resolved'], error_lists['unresolved'], error_lists['backlog']

    # TODO: Implement the code that calculates how many errors with *the same error code* are shared between
    # the possible pairs of lists here. Then return a Dict like the one shown in the documentation string above,
    # e.g.:

    
    r_c =  [i["code"] for i in resolved]      #all the codes from resolved
    u_c =  [i["code"] for i in unresolved]    #all the codes from unresolved
    b_c =  [i["code"] for i in backlog]       #all the codes from backlog

    ru_c = len(set(r_c).intersection(u_c))      #intersection of errors from resolved and unresolved
    ub_c = len(set(u_c).intersection(b_c))      #intersection of errors from backlog and unresolved
    rb_c = len(set(r_c).intersection(b_c))      #intersection of errors from resolved and backlog
    
    return  {
        'resolved_unresolved': ru_c,
        'resolved_backlog': rb_c,
        'unresolved_backlog': ub_c
    }


#----------------------------------Logging Functions called from the Front end------------------------------------------------------

@app.post("/get_error_request")   #A function to log the Error requests from the from end
async def get_error_request(name:str,activity:int):
    global REQUESTS
    REQUESTS = REQUESTS + 1     #Increase the total request count by 1
    Activitylist = ["Resolved to Unresolved","Unresolved to Resolved","Backlog to Unresolved"]  #Activity List for the logging
    LOGGER.info('An Error Request to change from '+ Activitylist[activity-1] + " for " + str(name) +' is successfull!!. Total Requests:'+str(REQUESTS))

@app.post("/get_undo_request")   #A function to log the Undo requests from the from end
async def get_undo_request(name:str,activity:int) -> int:
    global REQUESTS
    REQUESTS = REQUESTS + 1    #Increase the total request count by 1
    if activity == 0:
        LOGGER.info('An Undo Request recieved from front end. No Undo Action Pending!! . Total Requests:'+str(REQUESTS))
    else:
        LOGGER.info('An Undo Request for the error ' + str(name) +' is successfull!!. Total Requests:'+str(REQUESTS))

#------------------------------------------------------------------------------------------------------------------------------------

def run(host: str, port: int) -> None:
    """Run the code challenge API."""
    uvicorn.run(app, host=host, port=port)
